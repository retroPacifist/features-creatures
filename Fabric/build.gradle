import net.fabricmc.loom.api.mappings.layered.MappingContext
import net.fabricmc.loom.api.mappings.layered.MappingLayer
import net.fabricmc.loom.api.mappings.layered.MappingsNamespace
import net.fabricmc.loom.api.mappings.layered.spec.MappingsSpec
import net.fabricmc.loom.configuration.providers.mappings.intermediary.IntermediaryMappingLayer
import net.fabricmc.mappingio.MappingVisitor
import net.fabricmc.mappingio.tree.MemoryMappingTree


buildscript {
    repositories {
        maven {
            url = 'https://maven.parchmentmc.org'
        }
        maven {
            name = 'Fabric'
            url = 'https://maven.fabricmc.net/'
        }
    }
    dependencies {
        classpath group: 'net.fabricmc', name: 'mapping-io', version: '0.3.0', changing: true
    }
}

plugins {
    id 'fabric-loom' version '0.11-SNAPSHOT'
    id 'maven-publish'
    id 'idea'
    id 'java'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

tasks.build.dependsOn(tasks.findByName("shadowJar"))

configurations {
    shadow
    implementation.extendsFrom(shadow)
}
shadowJar {
    configurations = [project.configurations.shadow]
}

archivesBaseName = "${mod_name}-fabric-${minecraft_version}"
repositories {
    maven {
        url "https://www.cursemaven.com"
        content {
            includeGroup "curse.maven"
        }
    }
    maven {
        name = "JitPack"
        url = "https://jitpack.io"
    }
}

dependencies {
    minecraft "com.mojang:minecraft:${minecraft_version}"
    mappings loom.layered() {
        officialMojangMappings()
        parchment("org.parchmentmc.data:parchment-1.18.2:${parchment_version}@zip")
        // https://gist.github.com/CorgiTaco/e4b5f7c968988e8c65bcf9f0093fd602
        // don't convert this to a dynamic instantiation, otherwise java won't see the overridden hashCode
            addLayer(new MappingsSpec<MappingLayer>() {
            final Map<String, String> METHOD_NAME_MAP = Map.of(
                    "getTextureLocation", "_getTextureLocation"
            )

            @Override
            MappingLayer createLayer(MappingContext mappingContext) {
                return new MappingLayer() {
                    @Override
                    void visit(MappingVisitor mappingVisitor) throws IOException {
                        MemoryMappingTree memoryMappingTree = mappingVisitor as MemoryMappingTree
                        memoryMappingTree.getClasses().forEach(classEntry -> {
                            classEntry.methods.forEach(methodEntry -> {
                                String newMethodName = METHOD_NAME_MAP.get(methodEntry.getName(MappingsNamespace.NAMED.toString()))
                                if (newMethodName != null) {
                                    //noinspection GroovyAccessibility
                                    methodEntry.srcName = newMethodName
                                }
                            })
                        })
                    }

                    @Override
                    MappingsNamespace getSourceNamespace() {
                        return MappingsNamespace.NAMED
                    }

                    @Override
                    List<Class<? extends MappingLayer>> dependsOn() {
                        return List.of(IntermediaryMappingLayer.class)
                    }
                }
            }

            @Override
            int hashCode() {
                // used to make sure caches stay consistent
                return METHOD_NAME_MAP.hashCode()
            }
        })
    }
    modImplementation "net.fabricmc:fabric-loader:${fabric_loader_version}"
    modImplementation "net.fabricmc.fabric-api:fabric-api:${fabric_version}"
    modImplementation 'software.bernie.geckolib:geckolib-fabric-1.18:3.0.42'
    implementation project(":Common")
}

loom {
    runs {
        client {
            client()
            setConfigName("Fabric Client")
            ideConfigGenerated(true)
            runDir("run")
        }
        server {
            server()
            setConfigName("Fabric Server")
            ideConfigGenerated(true)
            runDir("run")
        }
    }
}


processResources {
    from project(":Common").sourceSets.main.resources
    inputs.property "version", project.version

    filesMatching("fabric.mod.json") {
        expand "version": project.version
    }

    filesMatching('*.mixins.json') {
        expand "refmap_target": "${archivesBaseName}-"
    }
}

tasks.withType(JavaCompile) {
    source(project(":Common").sourceSets.main.allSource)
}

tasks.withType(Javadoc) {
    failOnError false
}

jar {
    from("LICENSE") {
        rename { "${it}_${mod_name}" }
    }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            groupId project.group
            artifactId project.archivesBaseName
            version project.version
            from components.java
        }
    }

    repositories {
        maven {
            url "file://" + System.getenv("local_maven")
        }
    }
}

remapJar {
    input.set shadowJar.archiveFile
}